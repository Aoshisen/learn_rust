//所有权的规则
/**
 * 1. 每一个值都有一个变量,这个变量是该值的所有者
 * 2. 每个值 同时   只能有一个所有者
 * 3. 所有者离开 作用域时 该若有者拥有的变量就会被删除
 */

// 作用域
/*
* 作用域就是程序中一个项目的有效范围
*
 */
fn main() {
    // x 未申明的时候是不可用的
    let x = "hello"; // 在x 申明了之后x 可以使用
    println!("{}", x); // 可以堆x 进行相关操作
                       // test()
    test3();
} // 在超出了作用域之后x 不能访问了
  //string 类型 不是标准的标量 类型
  //
  // fn test() {
  //     let x = "123";
  //     // 字面量 的string 类型,在申明的时候大小就固定了
  //     // 但是如果我们想要动态的获取用户的输入并保存,那么这个固定大小的string 类型显然就不满足条件了
  //     // rust 还提供了一个 string 的类型叫做 String,
  //     // String 存储在堆上面 heap ,并且能存储在编译时未知数量的文本
  //     let mut y = String::from("hello");
  //     y += "world";
  //     y.push_str(" world");
  //     println!("{},{}", x, y)
  //     // 字符串的内存处理以及分配
  //     // 对于字面量类型的 string 类型 ,在编译的时候就知道了字符串大小其文本内容可以直接硬编码到最终的可执行文件内部 (stack)
  //     // 对于String 类型,需要在heap 上去分配编译时未知的文本内容 所以操作系统就必须在运行时来请求内存 String::from
  //     // 对于String 类型在一些 具有GC 的语言中,GC 会跟踪并清理不在使用的内存,
  //     // 但是在Rust 中就需要我们去识别 内存何时不再被使用,然后去调用代码清除他
  //     // 1. 如果忘记清除内存,那么内存就会被浪费
  //     // 2. 如果过早的清除了内存,那么后续的代码执行就会找不到该值的位置
  //     // 3. 如果清除了两次,那么会引发bug
  //     // rust 采用了不同的方式释放内存
  //     // 如果一个变量超出了其作用范围,就会立即释放该内存并把其内存交还给操作系统drop 函数释放变量
  // }
  // 变量和数据交互的方式 move
  // fn test2() {
  //     //简单的数据类型
  //     let x = "10";
  //     let y = x;
  //     println!("{},{}", x, y)
  // }

fn test3() {
    // 复杂的String 类型
    let x = String::from("123");
    // 没有copy trait
    // 当x 被赋值给y 的时候赋值了一份该数据的指针,长度以及容量,并没有复制 存放在heap 上的值
    let y = x;
    println!("{},{}", y, y)
    // 当变量离开作用域范围的时候 会立即释放内存 ,这样,相同的内存被释放了两次,就会出现问题
    // double free
    //在rust 中如何解决double free 呢
    // 1. 首先没有采用复制一份heap 上的数据再生成一个新地址的方式
    // 2. rust 的做法是让 复制之前的变量废弃掉,这样 后续的释放内存的操作就只会执行一次
    // 相应的后续的 x 值也不能访问了,因为在y=x 的时候相当于是所有选的转交 转交完成之后新变量名字接管 值
}

// 变量和数据的交互方式Clone()
fn test4() {
    let x = String::from("123");
    let y = x.clone();
    println!("{},{}", x, y);
	// copy trait 可以用于整数这样的完全存放在stack 上的类型
	// 如果一个值实现了copy trait,那么旧的变量在复值后仍然可用
	// 如果一个值 或者一个值的一部分实现了drop trait 那么就不允许其实现copy trait 了

	// 常见的实现了copy trait 的类型
	// 1. 所有的标量类型
	// 任何需要分配内存或者是资源的 都不是copy 的
	// bool char 所有的浮点类型 tuple 如果所有的字段都是copy trait 的 那么元组也是copy 的
	let tuple=( 1,2 );
	// 下面就不是可以copy 的
	let tuple_false=( 1,String );
}

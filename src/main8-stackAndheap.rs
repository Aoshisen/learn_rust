// rust 的所有权机制
// rust 的核心机制就是所有权( 让rust 无需垃圾收集就可以保证内存的安全)
// 所有程序在运行时 都必须管理他们使用计算机内存的方式
//-  程序在运行的时候会不断的寻找 没有在使用的计算机内存,将他们释放
//- 在另一些语言中,没有垃圾回收的机制,在写代码的时候必须手动的释放 内存 比如c ,c++
// rust 采用了第三种方式
// rust 管理内存的方式是通过一个所有权系统来管理,其中包含一组编译器在编译时检查的规则
// - 这种方式发生在编译时期,所以程序运行时 就不会产生额外的开销 所以就不会减慢程序运行的速度
fn main() {}

/*
## 了解栈内存(stack)  和堆内存(heap)
1. stack 
  1.1 按照接受值的顺序存入值,然后按照后进先出的顺序取值(LIFO) 
  1.2 存入数据的过程叫压栈,
  1.3 取出数据的过程叫弹栈
  1.4 所有存储在stack 上的数据都必须有已知 的固定大小
  编译时大小未知的数据和大小可能发生变化的数据必须存放在堆内存上面

  2.heap
  heap 的数据组织性差一点
  当把数据存入到heap 上面时 ,会请求一定数量的空间
  操作系统会在堆上找到一块足够大的空间,把其标记为在用,并返回一个指针,这个指针就是这个空间的地址
  这个过程就叫做在堆上面进行分配,

  把数据放到栈上的操作不叫做分配,因为你的栈的内存空间是连续的,大小也是固定的
  而指针这种数据他的大小也是固定的,所以可以把指针放在stack 上
  如果想要访问指针所对应的数据,那么需要通过指针指向的地址来访问

  在stack 上分配存入数据比在heap 上存入数据快得多
  因为操作系统不需要寻找用来存放数据的空间,因为stack 的数据是连续的,当前存入的值的位置,永远在stack 的最顶端
  在heap 上分配数据 就要复杂很多了
  - 操作系统必须找到一个足够大的位置来存放数据,然后做好记录方便下次进行分配

  访问数据
  同样的通过stack 访问数据比heap 快得多
  heap 必须找到指针,再通过指针指向的地址来进行数据的访问
  - 现代处理器还有缓存的机制,指令在内存中跳转的次数越少,那么执行速度就会越快
  综合上诉条件 因为stack 上的数据是连续的,所以跳转次数少,那么执行速度就会越快
  而heap 上的数据比较远,那么处理速度就会慢一些
  并且 在 堆上分配空间也是需要时间的

  --函数调用
  函数调用开始的时候 ,函数本地的变量 (包括指向heap的指针)会被压入stack 中 ,当函数结束调用之后这些值会被释放

  所有权存在的原因
  跟踪代码的哪些部分正在使用heap 上的哪些数据
  最小化heap 上的重复数据量
  清理heap 上未使用的数据 避免空间不足
*/
